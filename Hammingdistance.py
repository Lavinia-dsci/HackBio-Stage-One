{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "c39dd61e-af2e-4dcf-b703-8f554796d874",
   "metadata": {},
   "outputs": [],
   "source": [
    "# ------------------------------\n",
    "# DNA -> Protein (Frame-based)\n",
    "# ------------------------------\n",
    "\n",
    "# 1) Standard genetic code (GeneScript).\n",
    "CODON_TABLE = {\n",
    "    \"TTT\":\"F\",\"TTC\":\"F\",\"TTA\":\"L\",\"TTG\":\"L\",\n",
    "    \"TCT\":\"S\",\"TCC\":\"S\",\"TCA\":\"S\",\"TCG\":\"S\",\n",
    "    \"TAT\":\"Y\",\"TAC\":\"Y\",\"TAA\":\"*\",\"TAG\":\"*\",\n",
    "    \"TGT\":\"C\",\"TGC\":\"C\", \"TGA\":\"*\",\"TGG\":\"W\",\n",
    "    \"CTT\":\"L\",\"CTC\":\"L\",\"CTA\":\"L\",\"CTG\":\"L\",\n",
    "    \"CCT\":\"P\",\"CCC\":\"P\",\"CCA\":\"P\",\"CCG\":\"P\",\n",
    "    \"CAT\":\"H\",\"CAC\":\"H\",\"CAA\":\"Q\",\"CAG\":\"Q\",\n",
    "    \"CGT\":\"R\",\"CGC\":\"R\",\"CGA\":\"R\",\"CGG\":\"R\",\n",
    "    \"ATT\":\"I\",\"ATC\":\"I\",\"ATA\":\"I\",\"ATG\":\"M\",\n",
    "    \"ACT\":\"T\",\"ACC\":\"T\",\"ACA\":\"T\",\"ACG\":\"T\",\n",
    "    \"AAT\":\"N\",\"AAC\":\"N\",\"AAA\":\"K\",\"AAG\":\"K\",\n",
    "    \"AGT\":\"S\",\"AGC\":\"S\",\"AGA\":\"R\",\"AGG\":\"R\",\n",
    "    \"GTT\":\"V\",\"GTC\":\"V\",\"GTA\":\"V\",\"GTG\":\"V\",\n",
    "    \"GCT\":\"A\",\"GCC\":\"A\",\"GCA\":\"A\",\"GCG\":\"A\",\n",
    "    \"GAT\":\"D\",\"GAC\":\"D\",\"GAA\":\"E\",\"GAG\":\"E\",\n",
    "    \"GGT\":\"G\",\"GGC\":\"G\",\"GGA\":\"G\",\"GGG\":\"G\",\n",
    "}\n",
    "\n",
    "# 2) Valid DNA characters we will accept (IUPAC basic + N for unknown).\n",
    "VALID_DNA_CHARS = set(\"ACGTN\")  # keep it simple for beginners\n",
    "\n",
    "# 3) Reverse complement map (for optional reverse-complement translation).\n",
    "REVCOMP_MAP = str.maketrans(\"ACGT\", \"TGCA\")\n",
    "\n",
    "\n",
    "def clean_dna(seq: str) -> str:\n",
    "    \"\"\"\n",
    "    Normalize DNA for translation.\n",
    "    - Uppercase\n",
    "    - Remove whitespace/newlines\n",
    "    - Replace U with T (handles RNA-like inputs)\n",
    "    \"\"\"\n",
    "    s = seq.upper()               # normalize case so codon keys match\n",
    "    s = s.replace(\"U\", \"T\")       # RNA base to DNA base\n",
    "    # Remove common layout noise (spaces, newlines, tabs, carriage returns)\n",
    "    s = s.replace(\" \", \"\").replace(\"\\n\", \"\").replace(\"\\t\", \"\").replace(\"\\r\", \"\")\n",
    "    return s\n",
    "\n",
    "\n",
    "def validate_dna(seq: str) -> None:\n",
    "    \"\"\"\n",
    "    Raise a clear error if sequence contains characters outside A/C/G/T/N.\n",
    "    Rationale: Beginners benefit from early, explicit errors rather than silent mistakes.\n",
    "    \"\"\"\n",
    "    bad = set(seq) - VALID_DNA_CHARS\n",
    "    if bad:\n",
    "        raise ValueError(f\"Invalid DNA characters found: {sorted(bad)}. \"\n",
    "                         \"Allowed: A,C,G,T,N. (Tip: check for digits, punctuation, or mixed bases like R/Y.)\")\n",
    "\n",
    "\n",
    "def reverse_complement(seq: str) -> str:\n",
    "    \"\"\"\n",
    "    Compute the reverse complement (useful if your input is the opposite strand).\n",
    "    \"\"\"\n",
    "    return seq.translate(REVCOMP_MAP)[::-1]\n",
    "\n",
    "\n",
    "def translate_dna(\n",
    "    seq: str,\n",
    "    frame: int = 0,\n",
    "    to_stop: bool = False,\n",
    "    unknown_aa: str = \"X\",\n",
    "    use_reverse_complement: bool = False,\n",
    ") -> str:\n",
    "    \"\"\"\n",
    "    Translate DNA to protein in a fixed reading frame.\n",
    "\n",
    "    Parameters\n",
    "    ----------\n",
    "    seq : str\n",
    "        DNA sequence (can contain whitespace/lowercase; 'U' is auto-converted to 'T').\n",
    "    frame : int\n",
    "        Reading frame to use: 0, 1, or 2. (0 means start at seq[0], 1 at seq[1], 2 at seq[2])\n",
    "    to_stop : bool\n",
    "        If True, stop translation at the first stop codon (TAA/TAG/TGA) and do not include '*'.\n",
    "        If False, keep translating and include '*' where stop codons occur.\n",
    "    unknown_aa : str\n",
    "        Amino acid to use when a codon contains unknown bases (e.g., 'N') or is not found: default \"X\".\n",
    "    use_reverse_complement : bool\n",
    "        If True, translate the reverse-complement strand (helpful for minus-strand/genomic context).\n",
    "\n",
    "    Returns\n",
    "    -------\n",
    "    protein : str\n",
    "        The translated amino-acid sequence.\n",
    "    \"\"\"\n",
    "    # --- sanitize input ---\n",
    "    dna = clean_dna(seq)  # uppercase, remove whitespace, U->T\n",
    "\n",
    "    # --- optional reverse-complement ---\n",
    "    if use_reverse_complement:\n",
    "        dna = reverse_complement(dna)\n",
    "\n",
    "    # --- basic quality gate: A/C/G/T/N only, catch errors early ---\n",
    "    validate_dna(dna)\n",
    "\n",
    "    # --- frame sanity check ---\n",
    "    if frame not in (0, 1, 2):\n",
    "        raise ValueError(\"frame must be 0, 1, or 2\")\n",
    "\n",
    "    # --- main translation loop ---\n",
    "    aa_list = []\n",
    "    # Iterate in steps of 3 starting at the chosen frame; stop before incomplete codons\n",
    "    for i in range(frame, len(dna) - 2, 3):\n",
    "        codon = dna[i:i+3]                   # get a triplet\n",
    "        aa = CODON_TABLE.get(codon, unknown_aa)  # map to amino acid or 'X'\n",
    "\n",
    "        if to_stop and aa == \"*\":            # optional early stop\n",
    "            break\n",
    "\n",
    "        aa_list.append(aa)\n",
    "\n",
    "    return \"\".join(aa_list)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "2115e967-10e2-4eef-a900-0f82b12163c8",
   "metadata": {},
   "outputs": [],
   "source": [
    "dna = \"ATGCCATGAAGTGCAAGTGCA\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "eb4dec6d-f8ef-4816-bf61-d2742bfd036b",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "anaconda-2024.02-py310",
   "language": "python",
   "name": "conda-env-anaconda-2024.02-py310-py"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.14"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
